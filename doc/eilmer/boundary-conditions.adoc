= Boundary Conditions

To complete a definition of a FluidBlock, boundary conditions for all
block boundaries, need to be specified.
These may be given as a list to the FluidBock constructor or
they may be attached to particular boundaries of an already existing
FluidBlock object.
In the absence of your specification, the default boundary condition
is a slip wall, `WallBC_WithSlip`.


== Walls

=== Slip wall

  WallBC_WithSlip:new{label, group}
  or
  WallBC_WithSlip0:new{label, group}

is used where we want a solid wall with no viscous effects.
The effect of the solid wall is achieved with the use of ghost cells and
an appropriate reflection of the velocity vector.
This is the default boundary condition where no other condition is specified.

`label`::
  _string_, default "" +
  A an optional tag string that may be applied to the boundary.

`group`::
  _string_, default "" +
  A an optional tag string that identifies the group to which this boundary belongs.
  It can be used, at run time and in postprocessing,
  to group the data for several boundaries together.
  This might be for force and moment estimation, for example.

There are variants to the basic wall condition.

  WallBC_WithSlip1:new{label, group}

achieves a similar effect to WallBC_WithSlip0 but without the use of ghost cell data.
To do this, the code makes use of one-sided flux-calculators at the boundary.
You will need to specify this variant of the boundary condition for a moving-grid
simulation where this boundary wall may have non-zero velocity.
The one-sided flux calculators will correctly handle the normal component of the
wall velocity while, effectively, the tangential velocity will be ignored.


  WallBC_WithSlip2:new{label, group}

is Ingo's variant of WallBC_WithSlip for moving mesh simulations for walls
with normal velocity.
It uses ghost cells with appropriate velocity settings.


=== No-slip, fixed-temperature

  WallBC_NoSlip_FixedT:new{Twall, label, group}
  or
  WallBC_NoSlip_FixedT0:new{Twall, label, group}

is used where we want convective and viscous effects to impose a no-slip velocity
condition and a fixed wall temperature.
The convective effect of the solid wall is achieved with the use of ghost cells and
an appropriate reflection of the velocity vector.
We need to set `config.viscous=true` to make the temperature-setting part
of this boundary condition effective.

`Twall`::
  The fixed wall temperature, in degrees K.


  WallBC_NoSlip_FixedT1:new{Twall, label, group}

is variant of the boundary condition that does not use ghost cells and
is suitable for moving-grid simulations.


=== No-slip, adiabatic

  WallBC_NoSlip_Adiabatic:new{label, group}
  or
  WallBC_NoSlip_Adiabatic0:new{label, group}

is used where we want convective and viscous effects to impose no-slip at the wall
but where there is no heat transfer.
We need to set `config.viscous=true` to make this boundary condition effective.


  WallBC_NoSlip_Adiabatic1:new{label, group}

is variant of the boundary condition that does not use ghost cells and
is suitable for moving-grid simulations.


=== Translating-surface, fixed-temperature

  WallBC_TranslatingSurface_FixedT:new{Twall, v_trans, label, group}

is used where we want convective and viscous effects to impose
a specified translating velocity condition and a fixed wall temperature,
in a simulation with no grid motion.
By _translating_ we mean that the (flat) wall is moving tangential to the block boundary
such that the gas velocity is nonzero and aligned with the edge of the (fixed) grid.
We need to set `config.viscous=true` to make this boundary condition fully effective.
An example of use is Couette flow between moving plates.

`Twall`::
  The fixed wall temperature, in degrees K.

`v_trans`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Vector velocity of the translating wall.
  The value may be specified as a table of three named (x,y,z) components.


=== Translating-surface, adiabatic

  WallBC_TranslatingSurface_Adiabatic:new{v_trans, label, group}

is used where we want convective and viscous effects to impose
a specified translating velocity condition but no heat transfer,
in a simulation with no grid motion.
By _translating_ we mean that the (flat) wall is moving tangential to the block boundary
such that the gas velocity is nonzero and aligned with the edge of the (fixed) grid.
We need to set `config.viscous=true` to make this boundary condition fully effective.

`v_trans`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Vector velocity of the translating wall.
  The value may be specified as a table of three named (x,y,z) components.


=== Rotating-surface, fixed-temperature

  WallBC_RotatingSurface_FixedT:new{Twall, r_omega, centre, label, group}

is used where we want convective and viscous effects to impose
a specified velocity condition and a fixed wall temperature on a circular or cylindrical
fixed surface.
By _rotating_ we mean that the (curved) wall is moving tangential to the block boundary
such that the gas velocity is nonzero and aligned the edge of the (fixed) grid.
We need to set `config.viscous=true` to make this boundary condition fully effective.

`Twall`::
  The fixed wall temperature, in degrees K.

`r_omega`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Angular-velocity vector of the wall.
  The value may be specified as a table of three named (x,y,z) components.

`centre`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Axis about which the wall surface rotates.
  The value may be specified as a table of three named (x,y,z) components.

=== Rotating-surface, adiabatic

  WallBC_RotatingSurface_Adiabatic:new{r_omega, centre, label, group}

is used where we want convective and viscous effects to impose
a specified velocity condition but no heat transfer on a circular or cylindrical
fixed surface.
By _rotating_ we mean that the (curved) wall is moving tangential to the block boundary
such that the gas velocity is nonzero and aligned the edge of the (fixed) grid.
We need to set `config.viscous=true` to make this boundary condition fully effective.

`Twall`::
  The fixed wall temperature, in degrees K.

`r_omega`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Angular-velocity vector of the wall.
  The value may be specified as a table of three named (x,y,z) components.

`centre`::
  _Vector3_, default: {x=0.0, y=0.0, z=0.0} +
  Axis about which the wall surface rotates.
  The value may be specified as a table of three named (x,y,z) components.


== In-flow

=== Simple supersonic

  InFlowBC_Supersonic:new{flowState}

is used where we want to specify a fixed (supersonic) in-flow condition
that gets copied into the ghost cells each time step.

`flowState`::
  <<FlowState,_FlowState_>> object that has been constructed earlier in your script.


=== Static profile

  InFlowBC_StaticProfile:new{fileName, match}

is used where we want to specify an inflow condition that might vary
in a complicated manner across the boundary.
Data for the flow condition, on a per-cell basis, is contained in the specified file.
It may be that the file is obtained from an earlier simulation, with a post-processing
option like `--extract-line` used to write the file entries.
Matching of the ghost cells to particular entries in the data file is controlled by
the `match` string value,
where the default is to match to the nearest location on all three coordinates
of the ghost-cell position `match="xyz-to-xyz"`.

.Other possible values are
  * `"xyA-to-xyA"` For 2D or 3D simulations, don't care about z-component of position.
  * `"AyA-to-AyA"` For 2D or 3D simulations, care about the y-component of position only.
  * `"xy-to-xR"` Starting with a profile from a 2D simulation,
    map it to a radial profile in a 3D simulation, considering the x-component
    of the position of the ghost cells.
  * `"Ay-to-AR"` Starting with a profile from a 2D simulation,
    map it to a radial profile in a 3D simulation, ignoring the x-component
    of the position of the ghost cells.


=== Transient

  InFlowBC_Transient:new{fileName}

is used  where we want to specify the time-varying inflow condition at the boundary.
Data for the inflow condition,
at particular time instants and assumed uniform across the full boundary,
is contained in the specified file.
The user needs to write this file according to the expected format encoded
in the `FlowHistory` class, found toward the end of the `flowstate.d` module.
Each data line will have the following space-delimited items:

  time velx vely velz p T mass-fractions Tmodes (if any)


=== Constant flux

  InFlowBC_ConstFlux:new{flowState}

is used where we want to specify directly the fluxes of mass, momentum and energy
across the boundary faces.
The fluxes are computed from the supplied <<FlowState,_FlowState_>>.


=== Shock-fitting

  InFlowBC_ShockFitting:new{flowState}

is used where we want to have the inflow boundary be the location of a bow shock.
The fluxes across the boundary are computed from the supplied flow condition and the boundary
velocities are set to follow the shock.
Note that we need to set `config.moving_grid=true` and select
an appropriate gas-dynamic update scheme for the moving grid.

=== Isentropic from stagnation

  InFlowBC_FromStagnation:new{stagnationState, fileName,
    direction_type, direction_x, direction_y, direction_z,
    alpha, beta, mass_flux, relax_factor}

is used where we want a subsonic inflow with a particular stagnation pressure and
temperature and a velocity _direction_ at the boundary.
Note that many of the fields are shown with their default values,
so you don't need to specify them.
When applied at each time step, the average local pressure across the block boundary
is used with the stagnation conditions to compute a stream-flow condition.
Depending on the value for `direction_type`, the computed velocity's direction can be set

* `"normal"` to the local boundary,
* `"uniform"` in direction and aligned with direction vector whose components
  are `direction_x`, `direction_y` and `direction_z`
* `"radial"` radially-in through a cylindrical surface using flow angles
  `alpha` and `beta`, or
* `"axial"` axially-in through a circular surface using the same flow angles.

For the case with a nonzero value specified for `mass_flux`,
the current mass flux (per unit area) across the block face
is computed and the nominal stagnation pressure is incremented
such that the mass flux across the boundary relaxes toward the specified value.
Note that when we select a nonzero mass flux, we no longer control the stagnation pressure.
This will be adjusted to give the desired mass flux.
The value for `relax_factor` adjusts the rate of convergence for this feedback mechanism.

Note, that for multi-temperature simulations, all of the temperatures
are set to be the same as the transrotational temperature.
This should usually be a reasonable physical approximation because this boundary condition
is typically used to simulate inflow from a reservoir, and stagnated flow in a reservoir
has ample time to equilibriate at a common temperature.
The implementation of this boundary condition may not be time accurate,
particularly when large waves cross the boundary, however,
it tends to work well in the steady-state limit.

When `mass_flux` is zero and `fileName` is left as the default empty string,
the specified FlowState is used as a constant stagnation condition.
This may be modified by a user-defined function if `fileName` is a non-empty string
that give the name of a Lua script containing a function with the name `stagnationPT`
On every boundary condition application, this function receives a table of data
(including the current simulation time)
and returns values for stagnation pressure and temperature.

Here is a minimal example:
----
function stagnationPT(args)
   -- print("t=", args.t)
   p0 = 500.0e3 -- Pascals
   T0 = 300.0 -- Kelvin
   return p0, T0
end
----
The intention is that the user may program the stagnation pressure
as more interesting functions of time.


== Out-flow


=== Simple flux

  OutFlowBC_SimpleFlux:new{}


=== Simple extrapolation

  OutFlowBC_SimpleExtrapolate:new{xOrder}


=== Fixed pressure

  OutFlowBC_FixedP:new{p_outside}


=== Fixed pressure and temperature

  OutFlowBC_FixedPT:new{p_outside, T_outside}


== Inter-block Exchange

=== Full block-face

  ExchangeBC_FullFace:new{otherBlock, otherFace, orientation,
    reorient_vector_quantities, Rmatrix}


=== Mapped cell

  ExchangeBC_MappedCell:new{transform_position, c0, n, alpha, delta,
    list_mapped_cells, reorient_vector_quantities, Rmatrix}


== User Defined
This is a get-out-of-jail boundary condition that allows you to do anything
you wish to code (in Lua).


=== Setting ghost cells

   UserDefinedGhostCellBC:new{fileName, label, group, is_design_surface, num_cntrl_pts}


=== Setting fluxes

  UserDefinedFluxBC:new{fileName, funcName, label, group}


=== Full block-face followed by user-defined

  ExchangeBC_FullFacePlusUDF:new{otherBlock, otherFace, orientation,
    reorient_vector_quantities, Rmatrix, fileName, label, group}


