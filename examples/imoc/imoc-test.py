# imoc-test.py
# Try out the imoc kernel and unit processes.
#
# Usage:
# python3 imoc-test.py
#
# PJ, 2019-12-28, first step
#     2020-01-09, unit process for interior node
#     2022-01-11, unit processes return indices
#
import eilmer.imoc.kernel as kernel
import eilmer.imoc.unit_process as unit
from eilmer.ideal_gas_flow import PM1

import math

def approxEqual(a, b):
    result = math.isclose(a, b, rel_tol=1.0e-2, abs_tol=1.0e-5)
    # print("a=",a, "b=",b, "rel=",(a-b)/b, "abs=",a-b, "result=",result)
    return result

print("Begin imoc test...")
kernel.axisymmetric = False
kernel.g = 1.4

# Select the reference data from the MOC solution to the nozzle design
# in Anderson's Modern Compressible Flow text, example 11.1.
# Numbers are from the solution generated by the old IMOC code.
print("Define a couple of nodes.")
n3 = kernel.Node(x=0.051787, y=0.047831, nu=PM1(1.321), mach=1.321, theta=0.10472)
n9 = kernel.Node(x=0.067270, y=0.0, nu=PM1(1.321), mach=1.321, theta=0.0)
print("n3=", n3)
print("n9=", n9)

print("Make a new interior-node.")
n10indx = unit.interior(n3.indx, n9.indx, -1)
n10 = kernel.nodes[n10indx]
print("n3=", n3)
print("n9=", n9)
print("n10=", n10)
assert approxEqual(n10.theta, 0.052360), "interior node, flow angle"
assert approxEqual(n10.nu, 0.170169), "interior node, PM function"
assert approxEqual(n10.mach, 1.42638), "interior node, mach number"
assert approxEqual(n10.x, 0.081977), "interior node, x position"
assert approxEqual(n10.y, 0.017967), "interior node, y position"
assert (n10.cminus_up == n3.indx) and (n3.cminus_down == n10.indx), \
    "interior node, cminus connection"
assert (n10.cplus_up == n9.indx) and (n9.cplus_down == n10.indx), \
    "interior node, cplus connection"
kernel.mesh_indices.append(n3.indx)
kernel.mesh_indices.append(n9.indx)
kernel.mesh_indices.append(n10.indx)

print("Make a new wall-node along a C- characteristic.")
def f0(x): return 0.0
wall0 = kernel.Wall(f0, 0.0, 1.0)
n16indx = unit.cminus_wall(wall0, n10.indx, -1)
n16 = kernel.nodes[n16indx]
print("n16=", n16)
print("n10=", n10)
assert approxEqual(n16.theta, 0.0), "cminus wall node, flow angle"
assert approxEqual(n16.nu, 0.222529), "cminus wall node, PM function"
assert approxEqual(n16.mach, 1.52864), "cminus wall node, mach number"
assert approxEqual(n16.x, 0.101234), "cminus wall node, x position"
assert approxEqual(n16.y, 0.0), "cminus wall node, y position"
assert (n16.cminus_up == n10.indx) and (n10.cminus_down == n16.indx), \
    "cminus wall node, cminus connection"
kernel.mesh_indices.append(n16.indx)

print("Insert a node on that C- characteristic.")
nXXindx = unit.insert(n10.indx, n16.indx, -1, 0.5)
nXX = kernel.nodes[nXXindx]
print("nXX=", nXX)
print("n16=", n16)
print("n10=", n10)
assert (nXX.cminus_up == n10.indx) and (n10.cminus_down == nXX.indx), \
    "insert node on C- char, cminus connection A"
assert (n16.cminus_up == nXX.indx) and (nXX.cminus_down == n16.indx), \
    "insert node on C- char, cminus connection B"
kernel.mesh_indices.append(nXX.indx)

print("Extend a streamline.")
# Put a new point in a place where it is sure that the streamline will intersect
# one of the earlier characteristic lines.
# The flow angle is somewhat arbitrary.
# We just want to see that the new point gets put onto the characteristic line.
n999 = kernel.Node(x=0.051787, y=0.035, nu=PM1(1.321), mach=1.321, theta=0.10472/2)
kernel.mesh_indices.append(n999.indx)
alpha1, alpha2 = unit.streamline_intersection_weights(n999.indx, n3.indx, n10.indx)
print("alpha1=", alpha1, "alpha2=", alpha2)
n1000indx = unit.add_stream_node(n999.indx, n3.indx, n10.indx, -1)
n1000 = kernel.nodes[n1000indx]
kernel.mesh_indices.append(n1000.indx)

print("Make a new wall-node along a C+ characteristic.")
def f1(x): return 0.267949*x+0.111638
wall1 = kernel.Wall(f1, 0.0, 1.0)
n49 = kernel.Node(x=0.194488, y=0.142442, nu=PM1(1.83558), mach=1.83558, theta=0.261799)
n57indx = unit.cplus_wall(wall1, n49.indx, -1)
n57 = kernel.nodes[n57indx]
print("n49=", n49)
print("n57=", n57)
assert approxEqual(n57.theta, 0.261799), "cplus wall node, flow angle"
assert approxEqual(n57.nu, 0.379608), "cplus wall node, PM function"
assert approxEqual(n57.mach, 1.83558), "cplus wall node, mach number"
assert approxEqual(n57.x, 0.220358), "cplus wall node, x position"
assert approxEqual(n57.y, 0.170683), "cplus wall node, y position"
assert (n57.cplus_up == n49.indx) and (n49.cplus_down == n57.indx), \
    "cplus wall node, cplus connection"
kernel.mesh_indices.append(n49.indx)
kernel.mesh_indices.append(n57.indx)

kernel.walls = [wall0, wall1]

print("Done.")
