#! /usr/bin/env python3
# optimize.py
# Automatic code for finding the optimum nozzle contour for a Mach 4
# nozzle in the T4 shock tunnel.
# This script is based almost entirely off of
# dgd/examples/eilmer/2D/nozzle-optimize-bell/optimize.py
# The main changes were the objective function and the use of logfiles for capturing
# the simulation outputs rather than sending to terminal.
#
# originally written by PJ 2018-03-04 for ENGG7601 assignment
#
# Objective function used here is that of Craddock (2000), and Chan (2013)
# which aims to reduce the flow non-uniformity at the exit plane of the nozzle.
# In particular, the functions for flow uniformity and the objective function 
# were adapted from 
# cfcfd3/examples/eilmer3/2D/nenzfr-optimisation-UQ-X3R-M7-nozzle/optimise_X3R_Mach_7_nozzle.py
#
# Daniel Smith, 25-June-2020

import sys, os
DGDINST = os.path.expandvars("$HOME/dgdinst")
sys.path.append(DGDINST)

import matplotlib.pyplot as plt
import numpy as np
import shlex, subprocess, string, math
from scipy.optimize import minimize
from math import factorial, pow

np.set_printoptions(linewidth=100)

def eval_Bezier(bezCtrlPts, t):
    """
    Return the x- and y-coordinates of point t (0 < t < 1) on
    the Bezier curve generated by the input control points .
    """
    n = len(bezCtrlPts[:,0]) - 1
    blendingFunc = []
    # Generate blending functions.
    for i in range(len(bezCtrlPts[:,0])):
        blendingFunc.append((factorial(n) /(factorial(i)*factorial(n-i))) *\
            pow(t,i) * pow((1-t),(n-i)))
    # Get x and y coordinates.
    x = 0.0; y = 0.0
    for i in range(len(bezCtrlPts[:,0])):
        x += blendingFunc[i] * bezCtrlPts[i,0]
        y += blendingFunc[i] * bezCtrlPts[i,1]
    return x, y

def run_command(cmdText):
    """
    Run the command as a subprocess.
    """
    # Flush before using subprocess to ensure output
    # text is in the right order.
    sys.stdout.flush()    
    if (type(cmdText) is list):
        args = cmdText
    else:
        args = shlex.split(cmdText)
    with open("LOGFILE_CFD","wb") as out, open("LOGFILE_CFD_ERROR","wb") as err:
        return subprocess.check_call(args,stdout=out,stderr=err) #Show output in differnet logfiles, rather that in stdout
 

def prepare_input_script(substituteDict):
    """
    Prepare the actual input file for Eilmer4 from a template
    which has most of the Lua input script in place and just
    a few place-holders that need to be substituted for actual
    values.
    """
    fp = open("nozzle.template.lua", 'r')
    text = fp.read()
    fp.close()
    template = string.Template(text)
    text = template.substitute(substituteDict)
    fp = open("{0}.lua".format(jobname), 'w')
    fp.write(text)
    fp.close()
    return

def run_simulation(param_dict):
    prepare_input_script(param_dict)
    run_command('e4shared-debug --prep --job={0}'.format(jobname))
    run_command('mpirun -np 2 e4mpi --run --job={0} --verbosity=1'.format(jobname))
    return

def post_simulation_files():
    run_command('e4shared --post --job={0} --tindx-plot=last --vtk-xml --add-vars="mach,pitot,total-p,total-h" --slice-list="60:62,$,:,0" --output-file="{0}-exit.data"'.format(jobname))
    return

def flow_uniformity():
    """
    Reads in the most recent processed data called jobname-exit.data
    """
    #load in the most recent results
    data = np.loadtxt("{0}-exit.data".format(jobname),skiprows=1)

    # Secondary functions that contribute to the objective function.
    f_theta = 0.0; f_M = 0.0 # Initialise both functions to zero first.
    N = 0 # Initialise the counter for the number of cells in the core flow.
    for i in range(len(data[:,0])):
        # Definition used by Chris Craddock to estimate the boundary layer edge.

        M_i = data[i,18] #mach number
        y_i = data[i,1] #y-position

        vely_i = data[i,6]
        velx_i = data[i,5]

        if i == 0: 
            dMdy = 0.0  # Set to some number so that the first point 
                        # is not set as the boundary layer edge.
        else: 
            M_im1 = data[i-1,18]
            y_im1 = data[i-1,1]            
            dMdy = (M_i - M_im1) / (y_i - y_im1)
        # If dMdy >= -20.0, then we are in the core flow.
        if dMdy >= -20.0:
            f_theta += (vely_i / velx_i)**2
            f_M += (M_i - M_target)**2
            N += 1

    # Weight the secondary functions by weighting parameters.
    f_theta = phi_theta**2 / N * f_theta
    f_M = phi_M**2 / N * f_M

    return f_theta, f_M

def objective(params):
    """
    Given a list of parameter values, run a simulation and compute the flow uniformity
    """
    pdict = {"dy1":params[0], "dy2":params[1], "dy3":params[2], "dy4":params[3], "dy5":params[4], "dy6":params[5], "dy7":params[6]}

    print("--------------------------------------")
    print("Commencing simulation for x = ", params)
    run_simulation(pdict)
    post_simulation_files()
    print("Simulation complete.")
    f_theta, f_M = flow_uniformity()
    obj_funct = (f_theta + f_M)**2
    print("Objective function evaluated to ", obj_funct)
    return obj_funct

# Targets
M_target = 4.0        # Target Mach number
dtheta_target = 0.02  # Target variation in outflow angle (in degrees)
dM_target = 0.01      # Target variation in Mach number

# Weighting parameters.
phi_theta = 1.0 / np.tan(np.radians(dtheta_target))
phi_M = 1.0 / dM_target

jobname = "t4m4b" 

def main():
    """
    This script was built in stages.
    The if-statements are for testing the functions as the script
    was being developed. They might be still useful for exploring.
    """
    if 0:
        print("Let's run a simulation.")
        pdict = {"dy1":0.0, "dy2":0.0, "dy3":0.0, "dy4":0.0, "dy5":0.0, "dy6":0.0, "dy7":0.0}
        run_simulation(pdict)
        post_simulation_files()
    if 0:
        print("Compute the flow uniformity from previously run simulation.")
        f_theta, f_M = flow_uniformity()
        print("Mach uniformity = ", f_M)
        print("angular uniformity = ", f_theta)
    if 0:
        print("Evaluate objective function.")
        params = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] # [theta_init, alpha, beta, theta_cone]
        objv = objective(params)
        print("objective value=", objv)
    if 1:
        print("Let the optimizer take control and run the numerical experiment.")
        x0 = np.array([[-1.01359136e-03,1.40857503e-05,-9.27802658e-04,3.82603999e-04,2.39843018e-03,-2.91766389e-04,-3.60642387e-04]])
        result = minimize(objective, x0, method='Nelder-Mead', options={'disp':True, 'maxiter':5000, 'adaptive':True})
        print('optimized result:')
        print('    x=', result.x)
        print('    fun=', result.fun)
        print('    success=', result.success)
        print('    message=', result.message)

        #want to save the new set of bezier points for later
        bezCtrlPts_orig = np.loadtxt("Bezier-control-pts-{0}-initial.data".format(jobname),skiprows=1)

        bezCtrlPts_opt = bezCtrlPts_orig 

        for i in range(len(result.x)):
            bezCtrlPts_opt[i+2,1] = bezCtrlPts_opt[i+2,1] + result.x[i]

        np.savetxt("Bezier-control-pts-{0}.opt.data".format(jobname), bezCtrlPts_opt, header='#     x, m       y, m')
    return

if __name__ == "__main__":
    main()
